/*
 * Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

{
    classHeader = "CopyrightHeader.txt"

    parserClass = "io.ballerina.plugins.idea.parser.BallerinaParser"
    parserUtilClass="io.ballerina.plugins.idea.parser.BallerinaParserUtil"

    psiClassPrefix = "Ballerina"
    psiImplClassSuffix = "Impl"
    psiPackage = "io.ballerina.plugins.idea.psi"
    psiImplPackage = "io.ballerina.plugins.idea.psi.impl"
    psiImplUtilClass = "io.ballerina.plugins.idea.psi.impl.BallerinaPsiImplUtil"

    elementTypeHolderClass = "io.ballerina.plugins.idea.psi.BallerinaTypes"
    elementTypeClass = "io.ballerina.plugins.idea.psi.BallerinaCompositeElementType"

    tokenTypeClass = "io.ballerina.plugins.idea.psi.BallerinaTokenType"

    tokens = [

        // Separators
        SEMICOLON           = ';' ;
        COLON               = ':' ;
        DOUBLE_COLON        = '::' ;
        DOT                 = '.' ;
        COMMA               = ',' ;
        LEFT_BRACE          = '{' ;
        RIGHT_BRACE         = '}' ;
        LEFT_PARENTHESIS    = '(' ;
        RIGHT_PARENTHESIS   = ')' ;
        LEFT_BRACKET        = '[' ;
        RIGHT_BRACKET       = ']' ;
        QUESTION_MARK       = '?' ;

        // Arithmetic operators
        ASSIGN              = '=' ;
        ADD                 = '+' ;
        SUB                 = '-' ;
        MUL                 = '*' ;
        DIV                 = '/' ;
        POW                 = '^' ;
        MOD                 = '%';

        // Relational operators
        NOT                 = '!' ;
        EQUAL               = '==' ;
        NOT_EQUAL           = '!=' ;
        REF_EQUAL           = '===' ;
        REF_NOT_EQUAL       = '!==' ;
        GT                  = '>' ;
        LT                  = '<' ;
        GT_EQUAL            = '>=' ;
        LT_EQUAL            = '<=' ;
        AND                 = '&&' ;
        OR                  = '||' ;

        // Additional symbols
        RARROW              = '->' ;
        LARROW              = '<-' ;
        AT                  = '@' ;
        BACKTICK            = '`' ;
        RANGE               = '..' ;
        ELLIPSIS            = '...' ;
        PIPE                = '|' ;
        EQUAL_GT            = '=>' ;

        // Compound Assignment operators.
        COMPOUND_ADD        = '+=' ;
        COMPOUND_SUB        = '-=' ;
        COMPOUND_MUL        = '*=' ;
        COMPOUND_DIV        = '/=' ;

        // Safe assignment operator
        SAFE_ASSIGNMENT     = '=?' ;

        // Post Arithmetic operators.
        INCREMENT           = '++' ;
        DECREMENT           = '--' ;

        LINE_COMMENT        = 'regexp://[^\r\n]*'

        WHITE_SPACE = 'regexp:\s+'
        identifier = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
        DECIMAL_INTEGER_LITERAL = "regexp:\d+"
  ]

    extends("(Simple|Array|Nullable|Union|Group|Tuple|Object|InclusiveRecord|ExclusiveRecord)TypeName|BinaryAndExpression") = TypeName

    // This is to identify top level elements in a file.
    implements("(Type|Service|GlobalVariable|Function|Annotation|Constant)Definition") = "io.ballerina.plugins.idea.psi.impl.BallerinaTopLevelDefinition"

    generateTokenAccessors = true
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                        compilation unit                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CompilationUnit ::=(ImportDeclaration | NamespaceDeclaration)* (DefinitionWithoutAnnotationAttachments |  DefinitionWithMultipleAnnotationAttachments | DefinitionWithSingleAnnotationAttachment)* <<eof>>

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                  import/namespace declarations                                                    //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ImportDeclaration ::= import (OrgName DIV)? CompletePackageName PackageVersion? Alias? SEMICOLON {pin=1}
OrgName ::= identifier
CompletePackageName ::= PackageName (DOT PackageName)* {pin(".*")=1}
PackageName ::= identifier
PackageVersion ::= version VersionPattern {pin=1}
VersionPattern ::= DECIMAL_INTEGER_LITERAL | DECIMAL_FLOATING_POINT_NUMBER | DECIMAL_EXTENDED_FLOATING_POINT_NUMBER
Alias ::= as identifier {pin=1}
NamespaceDeclaration ::= xmlns QUOTED_STRING_LITERAL (as identifier)? SEMICOLON {pin=1}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                        top level definitions                                                      //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DefinitionWithMultipleAnnotationAttachments ::= documentationString? AnnotationAttachment AnnotationAttachment+ Definition {pin=3 elementType=Definition}
DefinitionWithSingleAnnotationAttachment ::= documentationString? AnnotationAttachment Definition {pin=2 elementType=Definition}
DefinitionWithoutAnnotationAttachments ::= documentationString? Definition {pin=2 elementType=Definition}

Definition ::= TypeDefinition | ServiceDefinition | FunctionDefinition | AnnotationDefinition | ConstantDefinition | GlobalVariableDefinition {recoverWhile=TopLevelDefinitionRecover}
private TopLevelDefinitionRecover ::= !(MARKDOWN_DOCUMENTATION_LINE_START|PARAMETER_DOCUMENTATION_START|RETURN_PARAMETER_DOCUMENTATION_START|AT|external|remote|client|abstract|public|type|typedesc|service|listener|function|enum|annotation|int|float|decimal|boolean|string|byte|map|xml|xmlns|json|table|any|stream|object|record|channel|const|final|var|future|identifier|'{')

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                         type definitions                                                          //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TypeDefinition ::= public? type identifier RecoverableTypeContent (RecoverableTypeBody)? SEMICOLON {pin=2}
RecoverableTypeContent ::= identifier {recoverWhile = TypeDefinitionRecover}
private TypeDefinitionRecover ::= !(LEFT_BRACE | LEFT_CLOSED_RECORD_DELIMITER | SEMICOLON)
RecoverableTypeBody ::= CloseRecordTypeBody | RecoverableBody
CloseRecordTypeBody ::= LEFT_CLOSED_RECORD_DELIMITER RecoverableCloseRecordContent RIGHT_CLOSED_RECORD_DELIMITER {pin=1}
RecoverableCloseRecordContent ::= any {recoverWhile=CloseRecordTypeBodyRecover}
private CloseRecordTypeBodyRecover ::= !(RIGHT_CLOSED_RECORD_DELIMITER)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                        service definitions                                                        //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ServiceDefinition ::= service identifier? on RecoverableAttachmentContent ServiceDefinitionBody {pin=3}
RecoverableAttachmentContent ::= identifier {recoverWhile = ServiceDefinitionRecover}
private ServiceDefinitionRecover ::= !(LEFT_BRACE)

ServiceDefinitionBody ::= LEFT_BRACE ObjectMethod* RIGHT_BRACE {pin=1 recoverWhile=RecoverableBodyContentRecover}
ObjectMethod ::= MethodDeclaration | MethodDefinition
MethodDeclaration ::= documentationString? NestedAnnotationAttachment* (public|private)? (remote|resource)? function AnyIdentifierName NestedFunctionSignature SEMICOLON
MethodDefinition ::= documentationString? NestedAnnotationAttachment* (public|private)? (remote|resource)? function AnyIdentifierName NestedFunctionSignature NestedRecoverableBody

NestedFunctionSignature ::= LEFT_PARENTHESIS RecoverableParameterContent RIGHT_PARENTHESIS returns? NestedRecoverableReturnType {pin=1}
NestedRecoverableReturnType ::= identifier {recoverWhile=NestedReturnParamRecover}
private NestedReturnParamRecover ::= !(SEMICOLON | NESTED_LEFT_BRACE)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                        function definitions                                                       //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FunctionDefinition ::= (public|private)? remote? function AnyIdentifierName FunctionSignature FunctionDefinitionBody {pin=3 methods=[getIdentifier]}

AnyIdentifierName ::= identifier
FunctionSignature ::= LEFT_PARENTHESIS RecoverableParameterContent RIGHT_PARENTHESIS returns? RecoverableReturnType {pin=1}
RecoverableParameterContent ::= identifier {recoverWhile=FunctionSignatureRecover}
private FunctionSignatureRecover ::= !(RIGHT_PARENTHESIS)
RecoverableReturnType ::= identifier {recoverWhile=ReturnParamRecover}
private ReturnParamRecover ::= !(EQUAL_GT | ASSIGN | LEFT_BRACE)

FunctionDefinitionBody ::= (ExprFunctionBodySpec SEMICOLON) | (ExternalFunctionBody SEMICOLON) | RecoverableBody
ExprFunctionBodySpec ::= EQUAL_GT identifier {pin=1 recoverWhile=ExprFuncBodyRecover}
private ExprFuncBodyRecover ::= !(SEMICOLON)

ExternalFunctionBody ::= ASSIGN AnnotationAttachment* external {pin=1 recoverWhile=ExternalFuncBodyRecover}
private ExternalFuncBodyRecover ::= !(SEMICOLON)

// IMPORTANT - "RecoverableBody" rule should be used for all the top level definition bodies, for proper grammar recovery.
RecoverableBody ::= LEFT_BRACE RecoverableBodyContent RIGHT_BRACE {pin=1}
RecoverableBodyContent ::= identifier {pin=1 recoverWhile=RecoverableBodyContentRecover}
private RecoverableBodyContentRecover ::= !(RIGHT_BRACE)

// IMPORTANT - "NestedRecoverableBody" rule should be used for all the 1st level definition bodies, for proper grammar recovery.
NestedRecoverableBody ::= NESTED_LEFT_BRACE NestedRecoverableBodyContent NESTED_RIGHT_BRACE {pin=1}
NestedRecoverableBodyContent ::= identifier {pin=1 recoverWhile=NestedRecoverableBodyContentRecover}
private NestedRecoverableBodyContentRecover ::= !(NESTED_RIGHT_BRACE)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                       annotation definitions                                                      //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
AnnotationDefinition ::= public? const? annotation RecoverableAnnotationContent SEMICOLON {pin=3}
RecoverableAnnotationContent ::= identifier {recoverWhile=AnnotationDefinitionRecover}
private AnnotationDefinitionRecover ::= !(SEMICOLON)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                     global variable definitions                                                   //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
GlobalVariableDefinition ::= varDefinition | listenerDefinition | typedVariableDefinition
private varDefinition ::= final? var RecoverableVariableDefinitionContent SEMICOLON {pin=2}
private listenerDefinition ::= public? listener RecoverableVariableDefinitionContent SEMICOLON {pin=2}
private typedVariableDefinition ::= final? TypeName identifier ASSIGN RecoverableVarDefContent SEMICOLON {pin=3}

TypeName ::= TupleTypeName
             | SimpleTypeName
             | GroupTypeName
             | ArrayTypeName
             | UnionTypeName
             | ObjectTypeName
             | NullableTypeName
             | InclusiveRecordTypeName
             | ExclusiveRecordTypeName

SimpleTypeName ::= NULL_LITERAL
                   | AnyTypeName
                   | AnyDataTypeName
                   | HandleTypeName
                   | ValueTypeName
                   | ReferenceTypeName
                   | TypeDescTypeName
                   | NilLiteral

AnyTypeName ::= any
AnyDataTypeName ::= anydata
TypeDescTypeName ::= typedesc
HandleTypeName ::= handle

ArrayTypeName ::= TypeName (LEFT_BRACKET (IntegerLiteral | MUL)? RIGHT_BRACKET)+
NullableTypeName ::= TypeName <<nullableTypePredicate>> QUESTION_MARK
UnionTypeName ::= TypeName (PIPE TypeName)+
GroupTypeName ::= LEFT_PARENTHESIS <<isGroupType>> TypeName RIGHT_PARENTHESIS {pin=1}
TupleTypeName ::=  LEFT_BRACKET ((TypeName (COMMA TypeName)* (COMMA TupleRestDescriptor)?) | TupleRestDescriptor) RIGHT_BRACKET {pin=1}
ObjectTypeName ::= ((client? abstract) | (abstract? client?)) object LEFT_BRACE ObjectBody RIGHT_BRACE {pin=2}
InclusiveRecordTypeName ::=  record RecoverableBody
ExclusiveRecordTypeName ::=  record LEFT_CLOSED_RECORD_DELIMITER RecoverableBodyContent RIGHT_CLOSED_RECORD_DELIMITER
ObjectBody ::= {recoverWhile=ObjectBodyRecover}
private ObjectBodyRecover ::= !(RIGHT_BRACE)

TupleRestDescriptor::= TypeName ELLIPSIS
ReferenceTypeName ::= BuiltInReferenceTypeName | UserDefineTypeName
UserDefineTypeName ::= NameReference
ValueTypeName ::=   boolean | int | float | decimal | string | byte
BuiltInReferenceTypeName ::= MapTypeName
                             | FutureTypeName
                             | XmlTypeName
                             | JsonTypeName
                             | StreamTypeName
                             | TableTypeName
                             | ServiceTypeName
                             | TypeDescReferenceTypeName
                             | ErrorTypeName
                             | FunctionTypeName

MapTypeName ::= map LT TypeName GT {pin=1}
FutureTypeName ::= future LT TypeName GT {pin=1}
XmlTypeName ::= xml (LT TypeName GT)? {pin=1}
JsonTypeName ::= json
TableTypeName ::= table LT TypeName GT {pin=1}
ErrorTypeName ::= error (LT TypeName (COMMA TypeName)? GT)? {pin=1}
StreamTypeName ::= stream (LT TypeName (COMMA TypeName)? GT)? {pin=1}
FunctionTypeName ::= function
ServiceTypeName ::= service
TypeDescReferenceTypeName ::=  typedesc LT TypeName GT {pin=2}

NilLiteral ::= LEFT_PARENTHESIS RIGHT_PARENTHESIS
IntegerLiteral ::= DECIMAL_INTEGER_LITERAL | HEX_INTEGER_LITERAL

RecoverableVarDefContent ::= identifier {recoverWhile=VarDefExpressionRecover}
private VarDefExpressionRecover ::= !(SEMICOLON)
RecoverableVariableDefinitionContent ::= identifier {recoverWhile=GlobalVariableDefinitionRecover}
private GlobalVariableDefinitionRecover ::= !(SEMICOLON)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                        constant definitions                                                       //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ConstantDefinition ::= public? const RecoverableConstantContent SEMICOLON  {pin=2}
RecoverableConstantContent ::= identifier {recoverWhile=ConstantDefinitionRecover}
private ConstantDefinitionRecover ::= !(SEMICOLON)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                             annotations                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
AnnotationAttachment ::= AT NameReference RecoverableBody? {pin=1}
NameReference ::= PackageReference identifier | identifier
PackageReference ::= identifier COLON {pin=2}

NestedAnnotationAttachment ::= AT NameReference NestedRecoverableBody? {pin=1}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                        markdown documentation                                                     //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
documentationString ::= documentationLine+ parameterDocumentationLine* returnParameterDocumentationLine? deprecatedAnnotationDocumentationLine?
documentationLine ::= MARKDOWN_DOCUMENTATION_LINE_START documentationContent {pin=1}
parameterDocumentationLine ::= parameterDocumentation parameterDescription*
returnParameterDocumentationLine ::= returnParameterDocumentation returnParameterDescription*
deprecatedAnnotationDocumentationLine ::= deprecatedAnnotationDocumentation deprecateAnnotationDescriptionLine*
documentationContent ::= documentationText?
parameterDescription ::= MARKDOWN_DOCUMENTATION_LINE_START documentationText?
returnParameterDescription ::= MARKDOWN_DOCUMENTATION_LINE_START documentationText?
deprecateAnnotationDescriptionLine ::= MARKDOWN_DOCUMENTATION_LINE_START documentationText?

//TODO: Fix documentation reference capturing.
documentationText ::= (documentationReference | referenceType | backtickedBlock | documentationTextContent)+
documentationReference ::= referenceType SINGLE_BACKTICK_CONTENT SINGLE_BACKTICK_MARKDOWN_END {pin=1}

referenceType ::= DOCTYPE
                | DOCSERVICE
                | DOCVARIABLE
                | DOCVAR
                | DOCANNOTATION
                | DOCMODULE
                | DOCFUNCTION
                | DOCPARAMETER
                | DOCCONST

parameterDocumentation ::= PARAMETER_DOCUMENTATION_START PARAMETER_NAME DESCRIPTION_SEPARATOR documentationText? {pin=3}
returnParameterDocumentation ::= RETURN_PARAMETER_DOCUMENTATION_START docParameterDescription
deprecatedAnnotationDocumentation ::= DEPRECATED_DOCUMENTATION
docParameterDescription ::= documentationText?

backtickedBlock ::=  tripleBacktickedBlock | doubleBacktickedBlock | singleBacktickedBlock
singleBacktickedBlock ::= SINGLE_BACKTICK_MARKDOWN_START SINGLE_BACKTICK_CONTENT? SINGLE_BACKTICK_MARKDOWN_END {pin=1}
doubleBacktickedBlock ::= DOUBLE_BACKTICK_MARKDOWN_START DOUBLE_BACKTICK_CONTENT? DOUBLE_BACKTICK_MARKDOWN_END {pin=1}
tripleBacktickedBlock ::= TRIPLE_BACKTICK_MARKDOWN_START TRIPLE_BACKTICK_CONTENT? TRIPLE_BACKTICK_MARKDOWN_END {pin=1}

documentationTextContent ::= MARKDOWN_DOCUMENTATION_TEXT | DOCUMENTATION_ESCAPED_CHARACTERS

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                             Unused tokens                                                         //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private StatementRecover ::= !(BOOLEAN_LITERAL|DECIMAL_INTEGER_LITERAL|HEX_INTEGER_LITERAL|OCTAL_INTEGER_LITERAL|BINARY_INTEGER_LITERAL|NULL_LITERAL|DECIMAL_FLOATING_POINT_NUMBER|HEXADECIMAL_FLOATING_POINT_LITERAL|int|string|float|decimal|boolean|byte|any|anydata|json|xml|xmlns|map|table|function|stream|'{'|'['|'}'|';'|typedesc|future|var|while|match|foreach|continue|break|fork|try|throw|return|abort|aborted|committed|retry|fail|lock|transaction|if|forever|object|service|check|checkpanic|error|panic|from|worker|record|identifier|wait)
private ExpressionRecover ::= !(NULL_LITERAL|int|string|float|boolean|byte|any|map|table|typeof|function|stream|'}'|';'|var|while|match|foreach|continue|break|fork|try|throw|return|abort|aborted|committed|fail|lock|xmlns|transaction|if|forever|object|trap|wait|flush|error|check|checkpanic)

unused_Resource ::= resource
unused_Returns ::= returns
unused_Catch ::= catch
unused_Else ::= else
unused_Finally ::= finally
unused_Handle ::= handle
unused_In ::= in
unused_Is ::= is
unused_Let ::= let
unused_New ::= new
unused_ObjInit ::= OBJECT_INIT
unused_OnRetry ::= onretry
unused_Retries ::= retries
unused_Source ::= source
unused_Start ::= start
unused_TypeField ::= TYPE_FIELD
unused_TypeParameter ::= TYPE_PARAMETER
unused_With ::= with
unused_Select ::= select
unused_Where ::= where
unused_Do ::= do
unused_Elvis ::= ELVIS
unused_RARROW ::= SYNCRARROW
unused_Parameter ::= PARAMETER

unused_stringTemPlateExpressionStart ::= STRING_TEMPLATE_EXPRESSION_START
unused_stringTemPlateExpressionEnd ::= STRING_TEMPLATE_EXPRESSION_END
unused_BitAnd ::= BITAND
unused_BitXor ::= BITXOR
unused_BitComplement ::= BIT_COMPLEMENT
unused_CompoundBitOr ::= COMPOUND_BIT_OR
unused_CompoundBitAnd ::= COMPOUND_BIT_AND
unused_CompoundBitXor ::= COMPOUND_BIT_XOR
unused_XmlAllChar ::= XML_ALL_CHAR
unused_XmlLiteralEnd ::= XML_LITERAL_END
unused_StringTemplateText ::= STRING_TEMPLATE_TEXT
unused_StringTemplateLiteralStart ::= STRING_TEMPLATE_LITERAL_START
unused_StringTemplateLiteralEnd ::= STRING_TEMPLATE_LITERAL_END
unused_AnnotationAccess ::= ANNOTATION_ACCESS
unused_OptionalFieldAccess ::= OPTIONAL_FIELD_ACCESS
unused_CompoundLeftShift ::= COMPOUND_LEFT_SHIFT
unused_CompoundRightShift ::= COMPOUND_RIGHT_SHIFT
unused_HalfOpenRange ::= HALF_OPEN_RANGE
unused_Default ::= DEFAULT
unused_b16Blob ::= BASE_16_BLOB_LITERAL
unused_b64Blob ::= BASE_64_BLOB_LITERAL
unused_CompoundLogicalShift ::= COMPOUND_LOGICAL_SHIFT
unused_xmlLiteralStart ::= XML_LITERAL_START
unused_leftBrace ::= IGNORED_LEFT_BRACE
unused_rightBrace ::= IGNORED_RIGHT_BRACE
